{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"developer-guide/contribution.html","title":"Contributing","text":"<p>There are several ways in which you may contribute to this project.</p> <ul> <li>File issues</li> <li>Submit a pull requests</li> </ul>"},{"location":"developer-guide/contribution.html#found-a-bug-or-missing-feature","title":"Found a bug or missing feature?","text":"<p>Please file an issue in our issue tracking system.</p>"},{"location":"developer-guide/contribution.html#submit-a-pull-request","title":"Submit a Pull Request","text":"<p>If you found a solution to an open issue and implemented it, we would be happy to add your contribution in the code base. For doing so, please create a pull request. Prior to that, please make sure you</p> <ul> <li>rebased against the <code>develop</code> branch</li> <li>stick to project coding conventions</li> <li>added test cases for the problem you are solving</li> <li>added docs, describing the change</li> <li>generally comply with Codeacy report</li> </ul>"},{"location":"developer-guide/project-setup.html","title":"Project Setup","text":"<p>If you are interested in developing and building the project please read the following the instructions carefully.</p>"},{"location":"developer-guide/project-setup.html#version-control","title":"Version control","text":"<p>To get sources of the project, please execute:</p> <pre><code>git clone https://github.com/holunda-io/c7.git\ncd c7\n</code></pre> <p>We are using gitflow in our git SCM for naming branches. That means that you should start from <code>develop</code> branch, create a <code>feature/&lt;name&gt;</code> out of it and once it is completed create a pull request containing it. Please squash your commits before submitting and use semantic commit messages, if possible.</p>"},{"location":"developer-guide/project-setup.html#project-build","title":"Project Build","text":"<p>Perform the following steps to get a development setup up and running.</p> <pre><code>./mvnw clean install\n</code></pre>"},{"location":"developer-guide/project-setup.html#integration-tests","title":"Integration Tests","text":"<p>By default, the build command will ignore the run of <code>failsafe</code> Maven plugin executing the integration tests (usual JUnit tests with class names ending with ITest). In order to run integration tests, please call from your command line:</p> <pre><code>./mvnw -Pitest\n</code></pre>"},{"location":"developer-guide/project-setup.html#project-build-modes-and-profiles","title":"Project build modes and profiles","text":""},{"location":"developer-guide/project-setup.html#documentation","title":"Documentation","text":"<p>We are using MkDocs for generation of a static site documentation and rely on markdown as much as possible.</p> <p>Note</p> <p>If you want to develop your docs in 'live' mode, run <code>mkdocs serve</code> and access the http://localhost:8000/ from your browser.</p> <p>For creation of documentation, please run:</p>"},{"location":"developer-guide/project-setup.html#generation-of-javadoc-and-sources","title":"Generation of JavaDoc and Sources","text":"<p>By default, the sources and javadoc API documentation are not generated from the source code. To enable this:</p> <pre><code>./mvnw clean install -Prelease -Dgpg.skip=true\n</code></pre>"},{"location":"developer-guide/project-setup.html#continuous-integration","title":"Continuous Integration","text":"<p>GitHub Actions are building all branches on commit hook (for codecov). In addition, a GitHub Actions are used to build PRs and all branches.</p>"},{"location":"developer-guide/project-setup.html#publish-a-new-release","title":"Publish a new release","text":"<p>We use gitflow plugin to handle versioning and branch manipulations between <code>develop</code> and <code>master</code>. Technically, every push to the <code>master</code> branch triggers the execution of the GH actions job producing a release and publishing it into Maven Central. To do it correctly (with correct versions) please run:</p> <pre><code>./mvnw gitflow:release-start\n</code></pre> <p>Acknowledge the proposed version (or change if needed) and then run:</p> <pre><code>./mvnw gitflow:release-finish\n</code></pre>"},{"location":"developer-guide/project-setup.html#milestone-release-management","title":"Milestone / Release Management","text":"<p>After the publication of the new release, it is time to tell the users that you produced a new version. The <code>GitHub release</code> is produced by using the GitHub feature <code>Close Milestone</code>. A special GitHub action is preparing the release notes as a draft. Then click on <code>Publish Release</code> to make it public. This will trigger some GitHub internal notifications and people subscribed to notification about the library will get notified.</p>"},{"location":"developer-guide/project-setup.html#what-modules-get-deployed-to-repository","title":"What modules get deployed to repository","text":"<p>Every Maven module is enabled by default. If you want to change this, please provide the property</p> <pre><code>&lt;maven.deploy.skip&gt;true&lt;/maven.deploy.skip&gt;\n</code></pre> <p>inside the corresponding <code>pom.xml</code>. Currently, all <code>examples</code> are EXCLUDED from publication into Maven Central.</p>"},{"location":"getting-started/c7-admin-process-registry.html","title":"Admin Process Registry","text":""},{"location":"getting-started/c7-admin-process-registry.html#why-should-i-use-this","title":"Why should I use this?","text":"<p>You are developing an application and need to build a small function called by the ops or by developers directly  from the Camunda 7 tool stack available? You might create a REST resource, deploy swagger-ui, configure security, provide good examples and instructions for the user... Or you implement a simple function and deploy it as a  simple one-service process start-able from the Camunda Tasklist. </p>"},{"location":"getting-started/c7-admin-process-registry.html#how-to-start","title":"How to start?","text":""},{"location":"getting-started/c7-admin-process-registry.html#install-dependency","title":"Install dependency","text":"<p>Add the following dependency to your project classpath:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-admin-process-registry&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/c7-admin-process-registry.html#define-a-bean-factory-for-your-admin-process","title":"Define a Bean Factory for your Admin Process","text":"<p>Define a Bean Factory for an Admin Process Bean like this:</p> <pre><code>  import io.holunda.camunda.platform.adminprocess.AdminProcess\n\n\n  @Bean\n  fun helloWorldAdminProcess(): AdminProcess {\n\n    val foo = StringField(\"foo\", \"Foo - enter your name\")\n    val date = DateField(\"date\", \"Date - select some magic\")\n\n    return adminProcess(\n      activityId = \"helloWorld\",\n      label = \"Hello World 2\",\n      formFields = listOf(foo, date)\n    ) {\n\n      val variables = CamundaBpmData.reader(it)\n\n      logger.info { \"\"\" Hi, I am the process running with:\n          * foo: ${variables.get(foo)}\n          * date: ${variables.get(date)}\n        \"\"\".trimIndent()\n      }\n    }\n  }\n</code></pre>"},{"location":"getting-started/c7-deployment.html","title":"Deployment","text":""},{"location":"getting-started/c7-deployment.html#why-should-i-use-this","title":"Why should I use this?","text":"<p>This library offers an alternative way to deploy processes and decisions (and even cases)  to Camunda 7 and replaces the default Camunda auto deployment mechanism.</p> <p>Why would you want to do that? There are mainly two reasons:</p> <ul> <li>Camunda's auto deployment cannot handle multi-tenant deployments within SpringBoot applications,  as it does not properly discover the resources within the repackaged JAR</li> <li>The default way to specify process archives in <code>processes.xml</code> is not as easy and SpringBoot-like  as defining it in YAML (which this library allows)</li> </ul>"},{"location":"getting-started/c7-deployment.html#how-to-start","title":"How to start?","text":""},{"location":"getting-started/c7-deployment.html#install-dependency","title":"Install dependency","text":"<p>Add the dependency to your project:</p> MavenGradle <p>Add to your <code>pom.xml</code></p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.holunda.deployment&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-bpm-spring-boot-deployment&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Add to your <code>build.gradle.kts</code></p> <pre><code>implementation(\"io.holunda.deployment:camunda-bpm-spring-boot-deployment:$version\")\n</code></pre>"},{"location":"getting-started/c7-deployment.html#disable-camunda-7-auto-deployment","title":"Disable Camunda 7 Auto Deployment","text":"<p>Note</p> <p>Make sure your application doesn't contain <code>processes.xml</code> on your classpath.</p> <p>In addition, set the following properties in your <code>application.yaml</code>:</p> application.yaml<pre><code>camunda:\n  bpm:\n    deployment:\n      enabled: false\n</code></pre>"},{"location":"getting-started/c7-deployment.html#configure","title":"Configure","text":"<p>Set-up the tenants and folders to deploy from in your application properties.</p> application.yaml<pre><code>camunda:\n  bpm:\n    deployment:\n      archives:\n        - name: Default\n          path: tenants/default\n        - name: TenantOne\n          tenant: one\n          path: tenants/one\n</code></pre>"},{"location":"getting-started/c7-webapp-autologin.html","title":"Webapp Auto Login","text":""},{"location":"getting-started/c7-webapp-autologin.html#why-should-you-use-it","title":"Why should you use it?","text":"<p>Because otherwise, you need to type again and again \"admin/admin\" or \"demo/demo\"  when developing locally and trying to log-in to local Camunda Webapp.</p> <p>Danger</p> <p>Important, never use this in production environment, since everyone can login to Camunda Webapp and cause harm to your system.</p>"},{"location":"getting-started/c7-webapp-autologin.html#how-to-start","title":"How to start?","text":""},{"location":"getting-started/c7-webapp-autologin.html#requirements","title":"Requirements","text":"<ul> <li>Spring Boot</li> <li>Camunda 7</li> </ul>"},{"location":"getting-started/c7-webapp-autologin.html#install-dependency","title":"Install dependency","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-platform-7-autologin&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/c7-webapp-autologin.html#add-some-configuration","title":"Add some configuration","text":"<p>Activate the auto-login in your <code>application.yaml</code>:</p> <pre><code>camunda:\n  bpm:\n    login:\n      enabled: true\n      user-id: admin\n</code></pre>"},{"location":"getting-started/c7-webapp-autologin.html#use-it","title":"Use it","text":"<p>Navigate to the URL of Camunda Webapp (Cockpit/Tasklist/Admin) you and will be already logged in.</p>"},{"location":"getting-started/camunda-bpm-correlate.html","title":"Correlate","text":""},{"location":"getting-started/camunda-bpm-correlate.html#why-should-i-use-this","title":"Why should I use this?","text":"<p>Imagine you integrate your Camunda Engine into a larger application landscape. In doing so the inter-system communication becomes important and questions on communication styles and patterns arise. In the world of self-contained systems, the asynchronous communication with messages is wide adopted. This library helps you to solve integration problems around correlation of messages with processes.</p>"},{"location":"getting-started/camunda-bpm-correlate.html#how-to-start","title":"How to start?","text":""},{"location":"getting-started/camunda-bpm-correlate.html#install-dependency","title":"Install Dependency","text":"<p>First install the extension using the corresponding ingress adapter (in this example we use Spring Cloud Stream for connecting with Kafka):</p> <pre><code>&lt;dependencies&gt;\n  &lt;!-- Core --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n    &lt;artifactId&gt;camunda-bpm-correlate-spring-boot-starter&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n\n  &lt;!-- Cloud Stream Ingress --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n    &lt;artifactId&gt;camunda-bpm-correlate-spring-cloud-stream&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n\n  &lt;!-- Kafka Binding --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-stream-binder-kafka&lt;/artifactId&gt;\n  &lt;/dependency&gt;\n\n&lt;/dependencies&gt;\n</code></pre>"},{"location":"getting-started/camunda-bpm-correlate.html#configuration","title":"Configuration","text":"<p>Please add the configuration of the extension:</p> <pre><code>correlate:\n  enabled: true\n  channels:\n    my-kafka-channel:\n      enabled: true\n      type: stream\n      beanName: special-name\n  batch:\n    mode: all # default fail_first -&gt; 'all' will correlate one message after another, resulting in ignoring the order of receiving\n    query:    # query scheduler\n      pollInitialDelay: PT10S\n      pollInterval: PT6S\n    cleanup:  # cleanup of expired messages\n      pollInitialDelay: PT1M\n      pollInterval: PT1M\n  message:\n    timeToLiveAsString: PT10S # errors during TTL seconds after receiving are ignored\n    payloadEncoding: jackson  # our bytes are actually JSON written by Jackson.\n  persistence:\n    messageMaxRetries: 5 # default 100 -&gt; will try to deliver 5 times at most\n    messageFetchPageSize: 100 # default 100\n  retry:\n    retryMaxBackoffMinutes: 5 # default 180 -&gt; maximum 5 minutes between retries\n    retryBackoffBase: 2.0 # value in minutes default 2.0 -&gt; base in the power of retry to calculate the next retry\n</code></pre> <p>Now configure your basic Spring Cloud Streams Kafka configuration to looks like this (or similar). Pay attention to the name of the function definition and the bindings' in channels. It results from the value of <code>correlate.channels.&lt;channel-nam&gt;.beanName</code> and accordingly is part of the expression to bind the parameter of the binding (<code>special-name-in-0</code>).</p> <pre><code>spring:\n  cloud:\n    stream:\n      function:\n        definition: special-name\n        bindings:\n          special-name-in-0: correlate-ingress-binding      \n      bindings:\n        correlate-ingress-binding:\n          content-type: application/json\n          destination: ${KAFKA_TOPIC_CORRELATE_INGRES:correlate-ingress}\n          binder: correlate-ingress-binder\n          group: ${KAFKA_GROUP_ID}\n      binders:\n        correlate-ingress-binder:\n          type: kafka\n          defaultCandidate: false\n          inheritEnvironment: false\n          environment:\n            spring:\n              kafka:\n                consumer:\n                  key-deserializer: org.apache.kafka.common.serialization.ByteArrayDeserializer\n                  value-deserializer: org.apache.kafka.common.serialization.ByteArrayDeserializer\n              cloud:\n                stream:\n                  kafka:\n                    binder:\n                      autoCreateTopics: false\n                      autoAddPartitions: false\n                      brokers: ${KAFKA_BOOTSTRAP_SERVER_HOST:localhost}:${KAFKA_BOOTSTRAP_SERVER_PORT:9092}\n                      configuration:\n                        security.protocol: ${KAFKA_SECURITY_PROTOCOL_OVERRIDE:PLAINTEXT}\n</code></pre>"},{"location":"getting-started/camunda-bpm-data.html","title":"Data","text":""},{"location":"getting-started/camunda-bpm-data.html#why-should-i-use-this","title":"Why should I use this?","text":"<p>If you are a software engineer and run process automation projects in your company or on behalf of the customer based on Camunda Process Engine, you probably are familiar with process variables. Camunda offers an API to access them and thereby manipulate the state of the process execution - one of the core features during process automation.</p> <p>Unfortunately, as a user of the Camunda API, you have to exactly know the variable type (so the Java class behind it). For example, if you store a String in a variable <code>\"orderId\"</code> you must extract it as a String in every piece of code. Since there is no code connection between the different code parts, but the BPMN process model orchestrates these snippets to a single process execution, it makes refactoring and testing of process automation projects error-prone and challenging.</p> <p>This library helps you to overcome these difficulties and make access, manipulation and testing process variables really easy and convenient. We leverage the Camunda API and offer you not only a better API but also some additional features.</p>"},{"location":"getting-started/camunda-bpm-data.html#how-to-start","title":"How to start?","text":""},{"location":"getting-started/camunda-bpm-data.html#add-dependency","title":"Add dependency","text":"<p>Current version available in Sonatype OSS Maven Central is:</p> <p>In Apache Maven add to your <code>pom.xml</code>:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.holunda.data&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-bpm-data&lt;/artifactId&gt;\n  &lt;version&gt;${camunda-bpm-data.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For Gradle Kotlin DSL add to your <code>build.gradle.kts</code>:</p> <pre><code>implementation(\"io.holunda.data:camunda-bpm-data:${camunda-bpm-data.version}\")\n</code></pre>"},{"location":"getting-started/camunda-bpm-data.html#declare-process-variable-factories","title":"Declare process variable factories","text":"<p>First you have to define your process variables, by providing the variable name and type. For providing the type, different convenience methods exist:</p> <p>Here is an example in Java:</p> <pre><code>import io.holunda.camunda.bpm.data.factory.VariableFactory;\nimport static io.holunda.camunda.bpm.data.CamundaBpmData.*;\n\npublic class OrderApproval {\n  public static final VariableFactory&lt;String&gt; ORDER_ID = stringVariable(\"orderId\");\n  public static final VariableFactory&lt;Order&gt; ORDER = customVariable(\"order\", Order.class);\n  public static final VariableFactory&lt;Boolean&gt; ORDER_APPROVED = booleanVariable(\"orderApproved\");\n  public static final VariableFactory&lt;OrderPosition&gt; ORDER_POSITION = customVariable(\"orderPosition\", OrderPosition.class);\n  public static final VariableFactory&lt;BigDecimal&gt; ORDER_TOTAL = customVariable(\"orderTotal\", BigDecimal.class);\n}\n</code></pre>"},{"location":"getting-started/camunda-bpm-data.html#access-process-variables-from-java-delegate","title":"Access process variables from Java Delegate","text":"<p>If you want to access the process variable, call methods on the <code>ProcessVariableFactory</code> to configure the usage context, and then invoke the variable access methods.</p> <p>Here is an example, how it looks like to access variable from <code>JavaDelegate</code> implemented in Java. In this example, the total amount is calculated from the amounts of order positions and stored in the process variable.</p> <pre><code>@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public JavaDelegate calculateOrderPositions() {\n    return execution -&gt; {\n      OrderPosition orderPosition = ORDER_POSITION.from(execution).get();\n      BigDecimal oldTotal = ORDER_TOTAL.from(execution).getOptional().orElse(BigDecimal.ZERO);\n      BigDecimal newTotal = oldTotal.add(orderPosition.getNetCost().multiply(BigDecimal.valueOf(orderPosition.getAmount())));\n      ORDER_TOTAL.on(execution).setLocal(newTotal);\n    };\n  }\n}\n</code></pre>"},{"location":"getting-started/camunda-bpm-data.html#variable-access-from-rest-controller","title":"Variable access from REST Controller","text":"<p>Now imagine you are implementing a REST controller for a user task form which loads data from the process application, displays it, captures some input and sends that back to the process application to complete the user task. By doing so, you will usually need to access process variables. Here is an example:</p> <pre><code>@RestController\n@RequestMapping(\"/task/approve-order\")\npublic class ApproveOrderTaskController {\n\n    private final TaskService taskService;\n\n    public ApproveOrderTaskController(TaskService taskService) {\n        this.taskService = taskService;\n    }\n\n    @GetMapping(\"/{taskId}\")\n    public ResponseEntity&lt;ApproveTaskDto&gt; loadTask(@PathVariable(\"taskId\") String taskId) {\n        Order order = ORDER.from(taskService, taskId).get();\n        return ResponseEntity.ok(new ApproveTaskDto(order));\n    }\n\n    @PostMapping(\"/{taskId}\")\n    public ResponseEntity&lt;Void&gt; completeTask(@PathVariable(\"taskId\") String taskId, @RequestBody ApproveTaskCompleteDto userInput) {\n        VariableMap vars = builder()\n            .set(ORDER_APPROVED, userInput.getApproved())\n            .build();\n        taskService.complete(taskId, vars);\n        return ResponseEntity.noContent().build();\n    }\n}\n</code></pre>"},{"location":"user-guide/index.html","title":"Overview","text":"<p>This user guide gives you insight of features, scenarios and application examples of the included components and libraries.</p>"},{"location":"user-guide/libraries-operations.html","title":"Operations Libraries Overview","text":"<p>Includes extensions used for improved operations of Camunda 7.</p> <ul> <li> <p> camunda-api</p> <p>API layer of Camunda 7 Java API</p> <p> Reference</p> </li> <li> <p> c7-commons-immutables</p> <p>Immutables implementation of Camunda 7 Java data objects</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-autologin</p> <p>Camunda 7 WebApp Autologin</p> <p> Reference</p> </li> <li> <p> camunda-admin-process-registry</p> <p>Process Registry for inline-defined one-function adin processes</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-rest-client-spring-boot</p> <p>Full-featured client for Camunda 7 REST API providing implementation of Camunda Java API</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/libraries-support.html","title":"Support Libraries Overview","text":"<p>Includes libraries built as improvements to Camunda 7 engine itself.</p> <ul> <li> <p> camunda-bpm-correlate</p> <p>Solution for correlation of messages with processes running in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-bpm-data</p> <p>Beautiful process data handling for Camunda 7.</p> <p> Reference</p> </li> <li> <p> camunda-bpm-spring-boot-deployment</p> <p>Take back control on artifact deployment in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-custom-batch</p> <p>Perform custom batch operations on the shoulders of the Camunda 7 Job executor</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/libraries-testing.html","title":"Testing Libraries Overview","text":""},{"location":"user-guide/libraries-testing.html#testing","title":"Testing","text":"<p>Includes features for testing.</p> <ul> <li> <p> camunda-bpm-jgiven</p> <p>Solution for correlation of messages with processes running in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-mockito</p> <p>Simplify mocking and stubbung for process testing in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-process-tet-coverage</p> <p>Visualise test process paths and ensure your process model coverage ratio</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/modules.html","title":"Modules","text":"<p>Here is the overview of currently supported modules:</p>"},{"location":"user-guide/modules.html#support","title":"Support","text":"<p>Includes libraries built as improvements to Camunda 7 engine itself.</p> <ul> <li> <p> camunda-bpm-correlate</p> <p>Solution for correlation of messages with processes running in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-bpm-data</p> <p>Beautiful process data handling for Camunda 7.</p> <p> Reference</p> </li> <li> <p> camunda-bpm-spring-boot-deployment</p> <p>Take back control on artifact deployment in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-custom-batch</p> <p>Perform custom batch operations on the shoulders of the Camunda 7 Job executor</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/modules.html#operations","title":"Operations","text":"<p>Includes extensions used for improved operations of Camunda 7.</p> <ul> <li> <p> camunda-api</p> <p>API layer of Camunda 7 Java API</p> <p> Reference</p> </li> <li> <p> c7-commons-immutables</p> <p>Immutables implementation of Camunda 7 Java data objects</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-autologin</p> <p>Camunda 7 WebApp Autologin</p> <p> Reference</p> </li> <li> <p> camunda-admin-process-registry</p> <p>Process Registry for inline-defined one-function adin processes</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-rest-client-spring-boot</p> <p>Full-featured client for Camunda 7 REST API providing implementation of Camunda Java API</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/modules.html#testing","title":"Testing","text":"<p>Includes features for testing.</p> <ul> <li> <p> camunda-bpm-jgiven</p> <p>Solution for correlation of messages with processes running in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-platform-7-mockito</p> <p>Simplify mocking and stubbung for process testing in Camunda 7</p> <p> Reference</p> </li> <li> <p> camunda-process-tet-coverage</p> <p>Visualise test process paths and ensure your process model coverage ratio</p> <p> Reference</p> </li> </ul>"},{"location":"user-guide/c7-admin-process-registry/index.html","title":"Overview","text":""},{"location":"user-guide/c7-admin-process-registry/index.html#motivation","title":"Motivation","text":"<p>Sometimes you need to execute small tasks or functions and integrate this execution into existing infrastructure with your enterprise set-up of security, user management and others. If you want to run administration tasks directly from the Camunda 7 Task list using auto-generated mini-processes.</p>"},{"location":"user-guide/c7-admin-process-registry/index.html#solution","title":"Solution","text":"<p>This lib/spring-boot-auto-config allows you to generate and deploy single-service-task processes that can be  started from the Camunda Webapp Tasklist. Doing so enables you to implement administration / house-keeping  jobs as a process, use Camunda's Form/UI and run tasks controlled with the full power of the engine,  including error handling and analysis.</p>"},{"location":"user-guide/c7-admin-process-registry/index.html#features","title":"Features","text":"<ul> <li>The created process will include one service task (with id <code>activityId</code> and label <code>label</code>), </li> <li>The service task will execute a fixed Java Delegate, calling the Admin Process Registry to resolve provided lambda expression</li> <li>The process will have provided <code>name</code>, <code>historyTtl</code> and an optional <code>tenantId</code></li> <li>The process is marked as <code>startable from tasklist</code></li> <li>If a list of form fields is supplied, the autogenerated-form will be shown in the task list</li> </ul>"},{"location":"user-guide/c7-admin-process-registry/examples.html","title":"Example","text":""},{"location":"user-guide/c7-admin-process-registry/examples.html#how-does-it-work","title":"How does it work","text":"<p>Add the following dependency to your project classpath:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-admin-process-registry&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Define a Bean Factory for an Admin Process Bean like this:  </p> <pre><code>  import io.holunda.camunda.platform.adminprocess.AdminProcess\n\n\n  @Bean\n  fun helloWorldAdminProcess(): AdminProcess {\n\n    val foo = StringField(\"foo\", \"Foo - enter your name\")\n    val date = DateField(\"date\", \"Date - select some magic\")\n\n    return adminProcess(\n      activityId = \"helloWorld\",\n      label = \"Hello World 2\",\n      formFields = listOf(foo, date)\n    ) {\n\n      val variables = CamundaBpmData.reader(it)\n\n      logger.info { \"\"\" Hi, I am the process running with:\n          * foo: ${variables.get(foo)}\n          * date: ${variables.get(date)}\n        \"\"\".trimIndent()\n      }\n    }\n  }\n</code></pre> <p>And you are done! The Spring Boot AutoConfiguration will register the bean  in the registry, generate the process model and deploy it.</p> <p>The generated model looks like this:</p> <p></p> <p>You can run the process in the webapp: </p> <p></p> <p>And fill out the form:</p> <p></p>"},{"location":"user-guide/c7-api/index.html","title":"C7 API","text":""},{"location":"user-guide/c7-api/index.html#coming-soon","title":"Coming Soon","text":""},{"location":"user-guide/c7-deployment/index.html","title":"C7 Deployment User Guide","text":""},{"location":"user-guide/c7-deployment/index.html#motivation","title":"Motivation","text":"<p>This library offers an alternative way to deploy processes and decisions to Camunda BPM and replaces the default Camunda auto deployment mechanism.</p> <p>Why would you want to do that? There are mainly two reasons:</p> <ul> <li>Camunda's auto deployment cannot handle multi tenant deployments within SpringBoot applications, as it does not properly discover the resources within the   repackaged JAR</li> <li>The default way to specify process archives in <code>processes.xml</code> is not as easy and SpringBoot-like as defining it in YAML (which this library allows)</li> </ul> <p>If you want to know more about the issue with SpringBoot, you can read this article on medium.</p>"},{"location":"user-guide/c7-deployment/index.html#activation","title":"Activation","text":"<p>The library configures itself by Spring Autoconfiguration and is enabled by default, if necessary you can still disable the deployment mechanism by adding the following property to your <code>application.yaml</code>:</p> <pre><code>camunda:\n  bpm:\n    deployment:\n      enabled: false\n</code></pre> <p>Note</p> <p>Make sure you disable Camunda's auto deployment! It is as easy as just deleting the <code>processes.xml</code>.</p>"},{"location":"user-guide/c7-deployment/index.html#configuration","title":"Configuration","text":"<p>Instead of <code>processes.xml</code> you have to configure the process archives in your <code>application.yaml</code>:</p> application.yaml<pre><code>camunda:\n  bpm:\n    deployment:\n      archives:\n        - name: Default\n          path: tenants/default\n        - name: TenantOne\n          tenant: one\n          path: tenants/one\n</code></pre> <p>If you don't specify a <code>tenant</code>, the tenant within Camunda will be <code>null</code>, which is the Camunda default.</p> <p>You have to place your resources in a folder structure that matches the specified archives:</p> <pre><code>src/main/resources\n  /tenants\n    /default\n      - firstProcess.bpmn\n    /one\n      - secondProcess.bpmn\n</code></pre> <p>It is possible that your tenant paths intersect. For example a common scenario is to have the default process application (without tenant) and then introduce a tenant contained in a certain folder at some day. This feature is deactivated by default to prevent misconfiguration and needs to be activated by setting <code>allow-overlapping</code> to <code>true</code>, configuring the archives accordingly. The configuration would look like this:</p> <p>application.yaml<pre><code>camunda:\n  bpm:\n    deployment:\n      allow-overlapping: true\n      archives:\n        - name: Default\n          path: # left empty to address the root of the resources folder and all subfolders.\n        - name: TenantOne\n          tenant: tenant-one\n          path: one # subfolder of the root resources folder \n</code></pre> As a result, all Camunda relevant files from the root of the classpath <code>src/main/resources</code> and all subdirectories, excluding <code>one</code> are deployed in a default archive (without a tenant). All resources from <code>src/main/resources/one</code> are deployed ina a second archive with tenant <code>tenant-one</code>.</p> <p>To deploy multiple folders for the same tenant the tenant uniqueness check needs to be disabled:</p> application.yaml<pre><code>camunda:\n  bpm:\n    deployment:\n      allow-overlapping: true\n      check-tenant-archive-uniqueness: false\n      archives:\n        - name: BPMN\n          path: bpmn\n        - name: DMN\n          path: dmn\n</code></pre>"},{"location":"user-guide/c7-immutables/index.html","title":"c7 immutables","text":""},{"location":"user-guide/c7-immutables/index.html#coming-soon","title":"Coming Soon","text":""},{"location":"user-guide/c7-jgiven/index.html","title":"C7 JGiven User Guide","text":""},{"location":"user-guide/c7-jgiven/index.html#coming-soon","title":"Coming Soon","text":""},{"location":"user-guide/c7-webapp-autologin/index.html","title":"Overview","text":""},{"location":"user-guide/c7-webapp-autologin/index.html#motivation","title":"Motivation","text":"<p>Camunda 7 Web Apps use Identity Service to grant access to the resources. Too simple for must real-world scenarios, it is time-wasting during the development process. Most of the time the developer either uses serious replacement for the embedded identity service (like OAuth2 login) or has to type user/password on every Web App access. Especially with the newest generation of the browsers detects the combination of <code>demo/demo</code> and <code>admin/admin</code> as  too trivial and insecure and proposing to change the dummy local development password after ever login-</p>"},{"location":"user-guide/c7-webapp-autologin/index.html#solution","title":"Solution","text":"<p>This library provides a solution to hook into the authentication filter used by Camunda 7 and perform a login with a username configured in the application properties.</p>"},{"location":"user-guide/c7-webapp-autologin/index.html#features","title":"Features","text":"<ul> <li>Creates Camunda <code>Authentication</code> with the username provided in the properties</li> <li>Optionally configures a different context path (default is <code>/camunda</code>)</li> <li>Optionally creates the user if he/she doesn't exist in <code>IdentityService</code></li> <li>Optionally generates a random password for the user</li> </ul>"},{"location":"user-guide/c7-webapp-autologin/examples.html","title":"Example","text":""},{"location":"user-guide/c7-webapp-autologin/examples.html#all-configuration-parameters","title":"All configuration parameters","text":"<pre><code>camunda:\n  bpm:\n    login:\n      enabled: true                     # enables the feature, disabled by default\n      user-id: admin                    # user id of the user, defaults to 'nobody'\n      camunda-context-path: /some-path  # path camunda webapp bound to, defaults to '/camunda'\n      create-if-absent: true            # will create a dummy user using internal \n                                        # identity service, defaults to 'false'\n      random-password: false            # flag to control the password of the auto-generated-user, \n                                        # defaults to 'true'. \n                                        # If false is selected, the password is equals to user id.             \n</code></pre>"},{"location":"user-guide/c7-webapp-autologin/examples.html#typical-configuration","title":"Typical configuration","text":"<p>A typical configuration is depicted below. We use the Camunda <code>admin-user</code> feature to create the user and login as such.</p> <pre><code>camunda:\n  bpm:\n    admin-user:                         # Create the admin user \n      id: admin\n      email: admin@localhost\n      first-name: Admin\n      last-name: Administratus\n      password: admin\n    login:                              # Autologin\n      enabled: true            \n      user-id: admin\n</code></pre>"},{"location":"user-guide/camunda-bpm-correlate/index.html","title":"Camunda BPM Correlate Overview","text":""},{"location":"user-guide/camunda-bpm-correlate/index.html#motivation","title":"Motivation","text":"<p>Correlation is about targeting a running workflow (for example running inside the Camunda Platform 7) containing the state update by an external system. Inside the Camunda Platform it is important that the message subscription is present at the time of correlation, otherwise the correlation is mismatched.</p> <p>If you are building a distributed system using the Camunda Platform 7 as a part of it, you should not make assumptions or assertions regarding the speed of processing of components, message ordering, message delivery or timings. To make sure that the correlation is not dependent on all those assumptions, the usage of inbox pattern to store the message locally and then deliver it timely on schedule is a good practise.</p>"},{"location":"user-guide/camunda-bpm-correlate/index.html#solution-architecture","title":"Solution Architecture","text":"<p>The library provides a core that is responsible for accepting the message, storing it into persistence storage and processing it scheduled. If any errors occur during the correlation, these are handled by one of the pre-configured error strategies, like retry, ignore or drop...</p> <p>In addition, there are a set of several ingress adapters to support different communication technologies.</p>"},{"location":"user-guide/camunda-bpm-correlate/index.html#main-features","title":"Main features","text":"<ul> <li>Ingress Adapters:<ul> <li>Spring Cloud Streams (e.g. Kafka Streams, Rabbit MQ, Azure Event Hubs, AWS SQS, AWS SNS, Solace PubSub+, Google PubSub)</li> <li>Axon Framework (Axon Event Bus)</li> </ul> </li> <li>Inbox pattern on message receiving</li> <li>MetaData extractors:<ul> <li>Message based (Headers)</li> <li>Channel based (Properties)</li> </ul> </li> <li>Persisting Message Accepting Adapter</li> <li>Message Persistence<ul> <li>In-Memory</li> <li>MyBatis (using the same DB as Camunda Platform 7)</li> </ul> </li> <li>Asynchronous batch processor running correlation on schedule<ul> <li>Batch modes: all, fail-first</li> </ul> </li> <li>Variety of error handling strategies on mismatched correlation (ignore, drop, retry)</li> <li>Configurable timings, retry strategies and many other parameters</li> <li>Message Buffering (TTL)</li> <li>Message Expiry</li> <li>Camunda Cockpit Plugin to display the content of the inbox table</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/index.html#external-references","title":"External References","text":"<ul> <li>Camunda Community Summit 2022 Talk</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/cockpit-plugin.html","title":"Correlation Cockpit Plugin","text":"<p>In order to be able to control the process of correlation via inbox storage, we created a cockpit plugin showing the messages in the system. In order to activate it, just add the following dependency to your  classpath:</p> <pre><code>&lt;dependendcy&gt;\n  &lt;groupId&gt;io.holunda&lt;/groupId&gt;\n  &lt;artifactId&gt;camunda-bpm-correlate-cockpit-plugin&lt;/artifactId&gt;\n&lt;/dependendcy&gt;\n</code></pre> <p>After restart of the Camunda 7 engine, navigate to the Cockpit WebApp and you will see an additional tab <code>Correlation</code>, showing the message overview.</p> <p></p> <p>The table above represents messages stored in the inbox table waiting for the correlation. The columns from left to right are:</p> <ul> <li>Message State</li> <li>Message id</li> <li>Payload type</li> <li>Time of ingestion via Ingress</li> <li>Number of retries left</li> <li>Time of next retry attempt</li> <li>Available actions (if available):<ul> <li>Show Stacktrace</li> <li>Change retry parameters (next retry, number of retries)</li> <li>Pause / Resume delivery</li> <li>Delete message</li> </ul> </li> </ul> <p>If the error is present, you will be able to see the stacktrace in causing the error during correlation:</p> <p></p> <p>To change message correlation parameters, click on the corresponding button:</p> <p></p> <p>The following message states are available:</p> <ul> <li>:glyphicon-ok-sign: green: ok</li> <li>:glyphicon-remove-sign: red: max retries reached</li> <li>:glyphicon-hourglass: orange: paused</li> <li>:glyphicon-circle-arrow-right: blue: retrying</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/examples.html","title":"Examples","text":"<p>We provide examples demonstrating the usage of the library with different messaging technologies. The general example is a \"Travel Reservation\" business process, aiming to book flights and a hotel  in a target city. The reservation process receives the customer name, the source city, the target city  and the dates of the travel. Using this information, it requests the flights by the flight service and  a hotel by the hotel service. The confirmed flight information and hotel information is stored inside  the process payload variables.</p> <p></p> <p>The following sequence diagram illustrates the timing of messages being passed:</p> <p></p> <p>As a result, the <code>HotelReservationConfirmed</code> is received before <code>FlightReservationConfirmed</code> causing a trouble, if message order is strict and must be preserved. In addition, at the time of the receiving of the first message, the process has not completed the long-running task of saving the details.</p> <p>In the following examples we are not focusing on demonstration of features resulting from the  race conditions (resolved faulty), but on purpose created illegal (unwished) message ordering, causing to fail the orchestration by design.</p>"},{"location":"user-guide/camunda-bpm-correlate/examples.html#software-requirements-to-run-examples","title":"Software requirements to run examples","text":"<ul> <li>Docker</li> <li>Docker-Compose</li> <li>KCat (formerly known as KafkaCat)</li> <li>JQ</li> <li>Curl</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/examples.html#spring-cloud-streams-with-kafka","title":"Spring Cloud Streams with Kafka","text":"<p>The example demonstrates the usage of the library using Kafka for communication. In doing so, we rely on the Spring Cloud Streams binding for Kafka. We constructed an example sending and  receiving data between services using Apache Kafka.</p> <p>To run the examples, you will need to have Docker installed on your machine. Please first run the build of the examples and construct the container images...To do so, please run:</p> <p><code>mvn clean install -Pdocker-assembly -f example</code></p> <p>Then start the provided images using the supplied docker-compose file, by running:</p> <p><code>docker-compose -f example/spring-cloud/docker-compose.yml up -d</code></p> <p>This command will start Apache Kafka, Zookeeper, Flight Service and Hotel Service locally. As a next step, open your IDE and run the  <code>io/holunda/camunda/bpm/example/kafka/TravelAgencyKafkaCorrelationApplication.kt</code> application by  providing the spring profile <code>camunda-correlate</code> (module <code>example/spring-cloud/reservation-kafka</code>).</p> <p>Having it all up-and running, you can send the first message, by using the provided script, which uses  <code>kcat</code>/<code>kafkacat</code> and <code>jq</code>. Please run:</p> <p><code>example/spring-cloud/example.sh reservation</code> </p> <p>to send the message to the reservation topic. As a result, the process should get started, and you should see the messages <code>[SEND BOOK FLIGHT]</code> and <code>[SEND BOOK HOTEL]</code> in your log, indicating that the messages are sent to corresponding topics. The services are executed delayed (2 secs, 5 secs), during the process  is executing the long-running task (saving the reservation details lasts 10 seconds), you will see the response messages coming in. For demonstration purposes, the service delays are configured in a way that the \"expected\" answer by the flight is received after the \"unexpected\" response from the hotel  is received. Therefor, you will see the exception (<code>MismatchedCorrelationException</code>) in the log first.</p> <p>After this, you can inspect the content of the inbox by calling an endpoint http://localhost:8080/admin/list-messages/, as alternative you might open the Camunda Cockpit and check the messages inside the plugin section <code>Correlation</code>.</p>"},{"location":"user-guide/camunda-bpm-correlate/examples.html#axon-events-aka-using-camunda-platform-7-as-microservice-orchestrator","title":"Axon Events aka using Camunda Platform 7 as Microservice Orchestrator","text":"<p>The example demonstrates the usage of the library using Axon Framework / Axon Server based communication. In doing so, We constructed an example sending and receiving data between services using Axon Command and Event Buses.</p> <p>To run the examples, you will need to have Docker installed on your machine. Please first run the build of the examples and construct the container images...To do so, please run:</p> <p><code>mvn clean install -Pdocker-assembly -f example</code></p> <p>Then start the provided images using the supplied docker-compose file, by running:</p> <p><code>docker-compose -f example/axon/docker-compose.yml up -d</code></p> <p>This command will start Axon Server, Flight Service and Hotel Service locally. As a next step, open your IDE and run the <code>io/holunda/camunda/bpm/example/axon/TravelAgencyAxonCorrelationApplication.kt</code> application (module <code>example/axon/reservation-axon</code>).</p> <p>Having it all up-and running, you can send the first message, by using the provided script, which uses <code>curl</code> and <code>jq</code>. Please run:</p> <p><code>example/axon/example.sh reservation</code></p> <p>to send the message to the REST-ful endpoint, which will emit an Axon event. As a result, the process should get started, and you should see the messages <code>[SEND BOOK FLIGHT]</code> and <code>[SEND BOOK HOTEL]</code> in your log, indicating that the commands are sent to. The services are executed delayed (2 secs, 5 secs), during the process is executing the long-running task (saving the reservation details lasts 10 seconds), you will see the response messages coming in. For demonstration purposes, the service delays are configured in a way that the \"expected\" answer by the flight is received after the \"unexpected\" response from the hotel is received. Therefor, you will see the exception (<code>MismatchedCorrelationException</code>) in the log first.</p> <p>After this, you can inspect the content of the inbox by calling an endpoint http://localhost:8080/admin/list-messages/.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html","title":"Message Filter","text":"<p>In messaging scenarios it is not uncommon that the message bus is transporting more types of message than the current system should consume. In this case, it is important to filter out and ignore the irrelevant messages and take only the relevant messages into consideration. In the same time, all messages still needs to be consumed in order not to block the follow-up messages. In order to filter the messages between the Ingress Adapter and the Message Acceptor we supply a special <code>MessageFilter</code> to filter out the supported messaged.</p> <pre><code>/**\n * Message filter to filter messages delivered to the message acceptor.\n */\ninterface MessageFilter {\n  /**\n   * Checks if the message should be delivered to the message acceptor.\n   * @param message message instance\n   * @param messageMetaData metadata of the message\n   * @return `true` if message should be accepted.\n   */\n  fun &lt;P&gt; accepts(message: AbstractChannelMessage&lt;P&gt;, messageMetaData: MessageMetaData): Boolean\n}\n</code></pre> <p>Feel free to implement your own filters and supply them as a Spring Bean or choose on of the predefined filter and use them in your setup.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#allmessagefilter","title":"AllMessageFilter","text":"<p>The <code>AllMessageFilter</code> accepts all messages received from the Ingress adapter. </p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#andcompositemessagefilter","title":"AndCompositeMessageFilter","text":"<p>The <code>AndCompositeMessageFilter</code> is a composite filter consisting of a list of <code>MessageFilter</code> implementations combined by a logical AND operator.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#orcompositemessagefilter","title":"OrCompositeMessageFilter","text":"<p>The <code>OrCompositeMessageFilter</code> is a composite filter consisting of a list of <code>MessageFilter</code> implementations combined by a logical OR operator.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#notmessagefilter","title":"NotMessageFilter","text":"<p>The <code>NotMessageFilter</code> is a filter inverting the application of a supplied <code>MessageFilter</code> implementation.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#typelistmessagefilter","title":"TypeListMessageFilter","text":"<p>The <code>TypeListMessageFilter</code> is a filter accepting all messages with a payload type being one of the specified types.</p>"},{"location":"user-guide/camunda-bpm-correlate/filtering-messages.html#typeexistsonclasspathmessagefilter","title":"TypeExistsOnClasspathMessageFilter","text":"<p>The <code>TypeExistsOnClasspathMessageFilter</code> is accepting all messages that payload type is available on the class path. </p>"},{"location":"user-guide/camunda-bpm-correlate/ingress-axon.html","title":"Axon Framework Ingress Adapter","text":"<p>The Axon Framework Ingress Adapter is responsible for receiving events on Axon Event bus and sending them for the correlation to the library. </p>"},{"location":"user-guide/camunda-bpm-correlate/ingress-axon.html#message","title":"Message","text":"<p>Axon Event Message is received and deserialized by Axon Framework, using the configured message de-serializer and passed to the ingress adapter. The adapter is reading headers from message <code>MetaData</code> and converts them into message headers. The payload is encoded into serializable payload using  the configured encoder (currently Jackson).</p>"},{"location":"user-guide/camunda-bpm-correlate/ingress-spring-cloud.html","title":"Spring Cloud Ingress Adapter","text":"<p>The Spring Cloud Ingress Adapter is a component responsible for receiving Spring Cloud messages (using configured binding like Kafka, AMQP or others) and  convert them into message format used by the library.</p>"},{"location":"user-guide/camunda-bpm-correlate/ingress-spring-cloud.html#message","title":"Message","text":"<p>Kafka Message is received and the Kafka headers are converted to message headers. </p>"},{"location":"user-guide/camunda-bpm-correlate/ingress.html","title":"Ingress Adapter","text":"<p>The ingress adapter is a component responsible for the adaptation of the communication technology to the uniform message format used in the library. It is responsible for creation the instance of a message including message headers and serialized message payload.</p> <p>The following Ingress Adapter are available out of the box:</p> <ul> <li>Axon Framework</li> <li>Spring Cloud Stream</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html","title":"Message Acceptor","text":"<p>The message acceptor is a component responsible to receive the message from the Ingress adapter and store it into the database. </p>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html#message-metadata","title":"Message Metadata","text":"<p>Along with the payload the message must contain metadata represented by the <code>MessageMetadata</code>. This metadata is extracted from the channel settings,  message payload and other sources. Usually the <code>MessageMetadata</code> instance can't be constructed at one place, so we supply the <code>MessageMetaDataExtractorChain</code> consisting of <code>MessageMetaDataSnippetExtractor</code> instances. By doing so, every aspect of metadata extraction is put in it own class and the result of the  extraction is gathered in one <code>MessageMetadata</code> instance.</p> <p>To simplify the construction of <code>MessageMetaDataExtractorChain</code> we supply several <code>MessageMetaDataSnippetExtractor</code> implementations:</p>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html#channelconfigmessagemetadatasnippetextractor","title":"ChannelConfigMessageMetaDataSnippetExtractor","text":"<p>The <code>ChannelConfigMessageMetaDataSnippetExtractor</code> is responsible for reading metadata from the channel configuration. Usually, channel configuration parameters like message encoding are extracted that way.</p>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html#headermessagemessagemetadatasnippetextractor","title":"HeaderMessageMessageMetaDataSnippetExtractor","text":"<p>The <code>HeaderMessageMessageMetaDataSnippetExtractor</code> is responsible for reading metadata from message headers. Most communication technologies support some concept of message headers and the corresponding Ingress Adapter is mapping those headers to message headers used in the library. By doing so,  you can influence message attributes on a message level. For example, if you are receiving different types of messages by the same ingress adapter, this is  the easiest way to detect the type of the message.</p>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html#message-filtering","title":"Message filtering","text":"<p>Sometimes, more messages are sent through the channel as needed to be received by the Ingress Adapter and needs to be accepted and stored by the library.  For this purpose, a special filtering component <code>MessageFilter</code> is configured in the <code>MessageAcceptor</code>. For more details, how to use the filter please check the Filtering messages section. </p> <p>You can configure what messages it will support and filter the messages that will be delivered to the message acceptor.</p>"},{"location":"user-guide/camunda-bpm-correlate/message-acceptor.html#persisting-channel-message-acceptor","title":"Persisting Channel Message Acceptor","text":"<p>To implement the inbox pattern, the message acceptor stores received messages in a persistent storage. For this purpose, the <code>PersistingChannelMessageAcceptor</code> is implemented. For more details, please check the Message Persistence section.</p>"},{"location":"user-guide/camunda-bpm-correlate/message-persistence.html","title":"Message Persistence","text":"<p>The messages received and accepted by the message acceptor are stored in a relation database. For doing so, we implemented a MyBatis mapper of the underlying entity in order to keep the dependency track as small as possible (MyBatis is a library used and supplied by Camunda Platform 7). For the persistence of the messages the library uses a database table <code>COR_MESSAGE</code> with the following structure:</p> Column Java Datatype JDBC Datatype Description ID String VARCHAR Message id (unique) PAYLOAD_ENCODING String VARCHAR Encoding of the payload PAYLOAD_TYPE_NAMESPACE String VARCHAR Namespace of the payload type, for example package PAYLOAD_TYPE_NAME String VARCHAR Simple type name of the payload type, for example class name PAYLOAD_TYPE_REVISION String VARCHAR Revision of the payload type. PAYLOAD ByteArray BINARY Byte array containing the encoded payload INSERTED Instant TIMESTAMP WITH TIMEZONE Timestamp of message ingestion TTL_DURATION String VARCHAR Time to live of the message as Duration string EXPIRATION Instant TIMESTAMP WITH TIMEZONE Expiration of the message as timestamp RETRIES Integer INTEGER Number of retries of message correlation NEXT_RETRY Instant TIMESTAMP WITH TIMEZONE Timestamp of the next retry ERROR String VARCHAR Last error stacktrace produced during correlation <p>Depending on your database you will need different SQL DDLs to create the underlying DB table. Here are some dialects, we already tried out:</p>"},{"location":"user-guide/camunda-bpm-correlate/message-persistence.html#ms-sql-azure-sql","title":"MS SQL / Azure SQL","text":"<p>We use <code>NVARCHAR</code> as a basic type for strings because of improved index performance for UTF-8 encoded strings.</p> <pre><code>CREATE TABLE COR_MESSAGE (\n    ID                     NVARCHAR(64) UNIQUE NOT NULL,\n    PAYLOAD_ENCODING       NVARCHAR(64)        NOT NULL,\n    PAYLOAD_TYPE_NAMESPACE NVARCHAR(128)       NOT NULL,\n    PAYLOAD_TYPE_NAME      NVARCHAR(128)       NOT NULL,\n    PAYLOAD_TYPE_REVISION  NVARCHAR(64),\n    PAYLOAD                BINARY(4096),\n    INSERTED               DATETIME2           NOT NULL,\n    TTL_DURATION           NVARCHAR(32),\n    EXPIRATION             DATETIME2,\n    RETRIES                INT                 NOT NULL,\n    NEXT_RETRY             DATETIME2,\n    ERROR                  NVARCHAR(MAX)\n);\n</code></pre>"},{"location":"user-guide/camunda-bpm-correlate/message-persistence.html#h2-hsql","title":"H2 / HSQL","text":"<pre><code>CREATE TABLE COR_MESSAGE (\n    ID                     VARCHAR2(64) UNIQUE NOT NULL,\n    PAYLOAD_ENCODING       VARCHAR2(64)        NOT NULL,\n    PAYLOAD_TYPE_NAMESPACE VARCHAR2(128)       NOT NULL,\n    PAYLOAD_TYPE_NAME      VARCHAR2(128)       NOT NULL,\n    PAYLOAD_TYPE_REVISION  VARCHAR2(64),\n    PAYLOAD                BINARY(4096),\n    INSERTED               TIMESTAMP           NOT NULL,\n    TTL_DURATION           VARCHAR2(32),\n    EXPIRATION             TIMESTAMP,\n    RETRIES                INTEGER             NOT NULL,\n    NEXT_RETRY             TIMESTAMP,\n    ERROR                  CLOB(10000)\n);\n</code></pre>"},{"location":"user-guide/camunda-bpm-correlate/metrics.html","title":"Metrics","text":"<p>In order to be able to monitor the library in operations, we expose different metrics using  standard Spring Boot approach and use Micrometer as the library. By doing so, we provide maximum flexibility for the integration of the metrics in your monitoring system (like Prometheus or others).</p> <p>The following metrics are provided:</p> Component Name Type Tags Description Ingress camunda_bpm_correlate_ingress_received_total counter channel Total number of messages received via given channel. Ingress camunda_bpm_correlate_ingress_accepted_total counter channel Total number of messages accepted via channel. Ingress camunda_bpm_correlate_ingress_ignored_total counter channel Total number of messages received but ignored via channel. Acceptor camunda_bpm_correlate_acceptor_persisted_total counter Total number of messages persisted in the inbox. Acceptor camunda_bpm_correlate_acceptor_dropped_total counter Total number of messages dropped instead of persisting in the inbox. Inbox camunda_bpm_correlate_inbox_message gauge status Number of messages in the inbox by status. The statuses are: total, retrying, in_progress, error, maxRetriesReached and paused. Correlation camunda_bpm_correlate_correlation_success counter Total number of messages successfully correlated. Correlation camunda_bpm_correlate_correlation_error counter Total number of messages correlated with error."},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html","title":"Scheduled Processing","text":"<p>After the messages are stored in the database, they get processed triggered by a scheduler. The processing is performed not for every message, but on message batches. A message batch is a collection of messages with the same <code>CorrelationHint</code>. This means that all messages from one batch will be correlated with the same process instance.</p> <p>The configuration of the scheduler is an important setting of the library and influences the time for correlation, error detection and error recovery. The following sections describe the configuration properties controlling the timing of the correlation.</p>"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#configuration-summary","title":"Configuration summary","text":"<p>Here is a configuration example:</p> <pre><code>correlate:\n  batch:\n    mode: all \n    query:    # query scheduler\n      pollInitialDelay: PT10S\n      pollInterval: PT6S\n    cleanup:  # cleanup of expired messages\n      pollInitialDelay: PT1M\n      pollInterval: PT1M\n  persistence: # persistence setting\n    messageMaxRetries: 100 \n    messageFetchPageSize: 100\n    messageBatchSize: 1\n  retry:\n    retryMaxBackoffMinutes: 5 \n    retryBackoffBase: 2.0 \n</code></pre> Property Values Meaning Default batch.mode <code>all</code>, <code>fail_first</code> Batch processing mode all batch.query.pollInitialDelay Duration in ISO8601 Start delay before correlation scheduler starts PT10S batch.query.pollInterval Duration in ISO8601 Delay between correlation attempts PT6S batch.cleanup.pollInitialDelay Duration in ISO8601 Start delay before clean-up scheduler starts batch.cleanup.pollInterval Duration in ISO8601 Delay between clean-ups persistence.messageMaxRetries Integer Maximum retries before giving up correlation 100 persistence.messageFetchPageSize Integer Paging size by message fetch 100 persistence.messageBatchSize Integer Limit the number of messages processed from a batch -1 retry.retryMaxBackoffMinutes Integer Maximum backoff-time  in minutes 180 retry.retryBackoffBase Float Base for exponential backoff-time 180"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#reading-message","title":"Reading message","text":"<p>Messages are read in batches which are paged. You can set-up the page size, the interval between reads and the initial delay from the application start.</p>"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#batch-correlation","title":"Batch correlation","text":"<p>Batches of messages are checked to fulfill the following criteria:</p> <ul> <li>Batch contains no messages with errors</li> <li>Batch contains messages with errors and all those are due to retry (now &lt; due, retry &lt; max-retries)</li> </ul> <p>Messages of one batch are correlated in order of their sorting. If a correlation error occurs, the batch correlation is either interrupted (<code>fail_first</code> mode) or the batch is correlated to the end (<code>all</code> mode).</p> <p>An important parameter for batch processing is the <code>message-batch-size</code>. This parameter specifies the number of messages taken from a batch for synchronous correlation. Effectively, this parameter has two interesting values. Set this parameter to <code>-1</code> (default) and all messages from one batch will be correlated directly one after another. Set this parameter to <code>1</code> and the batch will be constructed, but only the first message will be correlated in current run. If successful, the  next message will be fetched during the next message query (after the <code>batch.query.pollInterval</code>, which should be a small interval). By doing so, you can deal with asynchronous continuations in your process.</p>"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#error-detection","title":"Error detection","text":"<p>If the error is detected during the correlation, it is handled by the library. If the message time-to-live is set and the error happens during the TTL (the message is alive), the error is not noted (and not stored), but the message will be skipped and picked up by the next batch correlation. If the error happens after the message TTL or TTL is not set, the error is noted causing the following information to be stored along the message in the database:</p> <ul> <li>head of the exception stack trace occurred during the correlation</li> <li>value incremented by 1 in <code>attempt</code></li> <li>new due date for retry (now plus value in minutes of <code>retryBackoffBase</code> at the power of <code>attempt</code> but at most the <code>retryMaxBackOffMinutes</code>)</li> </ul>"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#message-processing-example","title":"Message processing example","text":"<p>Imagine the message inserted at a point in time with TTL of 10 seconds producing a correlation error which can't be resolved by retries. Imagine that the value of <code>retryMaxBackOffMinutes</code> is set to <code>10</code> and the <code>messageMaxRetries</code> is <code>5</code>.</p> Offset from ingested (sec) Why Attempt Next Retry from ingested (secs) 6 Picked up by batch correlation scheduler, error, no error recording because of TTL 0 null 12 Picked up by batch correlation scheduler, error, error noted 1 12sec offset + 2^0M = 12 + 60 = 72 18 Not picked up, because of error and next retry not due 1 72 72 Picked up by batch correlation scheduler, error, error noted 2 72sec offset + 2^1M = 72 + 120 = 192 192 Picked up by batch correlation scheduler, error, error noted 3 192sec offset + 2^2M = 192 + 240 = 432 432 Picked up by batch correlation scheduler, error, error noted 4 432sec offset + 2^3M = 432 + 480 = 922, but 600 sec is max = 600 600 Picked up by batch correlation scheduler, error, error noted 5 600 606 Not picked up, because of error and max retries are reached 5 600"},{"location":"user-guide/camunda-bpm-correlate/scheduled-processing.html#running-in-a-cluster","title":"Running in a cluster","text":"<p>For activation of the cluster support, please add the following configuration snippet to your <code>application.yml</code>:</p> <pre><code>correlate:\n  batch:\n    cluster:\n      enabled: true\n      queuePollLockMostInterval: PT5M\n</code></pre> <p>For a cluster operations it is important to synchronize the batch schedulers between the cluster nodes. For this purpose, the library Shedlock is used. Shedlock synchronizes the scheduled tasks using a RDBMS table (we are using a JDBC Lock Provider). Here are the required DDL snippets for some common databases, please see shedlock documentation for more information.</p> <pre><code>CREATE TABLE shedlock\n(\n    name       NVARCHAR(64)  NOT NULL,\n    lock_until DATETIME2     NOT NULL,\n    locked_at  DATETIME2     NOT NULL,\n    locked_by  NVARCHAR(255) NOT NULL,\n    PRIMARY KEY (name)\n);\n</code></pre> <pre><code>CREATE TABLE shedlock\n(\n    name       VARCHAR(64)  NOT NULL,\n    lock_until DATETIME2     NOT NULL,\n    locked_at  DATETIME2     NOT NULL,\n    locked_by  VARCHAR(255) NOT NULL,\n    PRIMARY KEY (name)\n);\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/index.html","title":"Overview","text":""},{"location":"user-guide/camunda-bpm-data/index.html#motivation","title":"Motivation","text":"<p>The main three features we support are:</p> <ul> <li>typed access to process variables</li> <li>building pre- and post-conditions using variable guards</li> <li>building anti-corruption layer for inter-process-communcation</li> </ul>"},{"location":"user-guide/camunda-bpm-data/index.html#typed-access-to-process-variables","title":"Typed access to process variables","text":"<p>Camunda BPM engine provide Java API to access the process variables. This consists of:</p> <ul> <li><code>RuntimeService</code> methods</li> <li><code>TaskService</code> methods</li> <li>Methods on <code>DelegateExecution</code></li> <li>Methods on <code>DelegateTask</code></li> <li><code>VariableMap</code></li> </ul> <p>All those methods requires the user of the API to know the variable type. Here is a usage example:</p> <pre><code>ProcessInstance processInstance = ...;\nList&lt;OrderPosition&gt; orderPositions = (List&lt;OrderPosition&gt;) runtimeService\n  .getVariable(processInstance.id, \"orderPositions\");\n</code></pre> <p>This leads to problems during refactoring and makes variable access more complicated than it is. This library addresses this issue and allows for more convenient type-safe process variable access.</p> <p>More details can be found in:</p> <ul> <li>Data in Process (Part 1)</li> <li>Data in Process (Part 2)</li> </ul>"},{"location":"user-guide/camunda-bpm-data/index.html#variable-guards","title":"Variable guards","text":"<p>Process automation often follows strict rules defined by the business. On the other hand, the process execution itself defines rules in terms of pre- and post-conditions on the process payload (stored as process variables in Camunda BPM). Rising complexity of the implemented processes makes the compliance to those rules challenging. In order to fulfill the conditions on process variables during the execution of business processes, a concept of <code>VariableGuard</code> is provided by the library. A guard consists of a set of <code>VariableConditions</code> and can be evaluated in all contexts, the variables are used in: <code>DelegateTask</code>, <code>DelegateExecution</code>, <code>TaskService</code>, <code>RuntimeService</code>, <code>VariableMap</code>.</p> <p>Here is an example of a task listener defining a <code>VariablesGuard</code> to test that the process variables <code>ORDER_APPROVED</code> and <code>APPROVER_ID</code> are set, which will throw a <code>GuardViolationException</code> if the condition is not met.</p> <pre><code>import static io.holunda.camunda.bpm.data.guard.CamundaBpmDataGuards.exists;\n\n@Component\nclass MyGuardListener extends DefaultGuardTaskListener {\n\n    public MyGuardListener() {\n        super(new VariablesGuard(List.of(exists(ORDER_APPROVED), exists(APPROVER_ID)), true);\n    }\n}\n</code></pre> <p>By default, all conditions of a <code>VariablesGuard</code> must be met in order to pass the validations. This behaviour can be explicitly defined by passing the <code>reduceOperator = VariablesGuard.ALL</code> when creating the <code>VariablesGuard</code>. The <code>reduceOperator</code> can take the following values:</p> <code>reduceOperator</code> Semantics <code>VariablesGuard.ALL</code> All <code>VariableCondition</code>s must be met <code>VariablesGuard.ONE_OF</code> At least ONE <code>VariableCondition</code> must be met"},{"location":"user-guide/camunda-bpm-data/index.html#anti-corruption-layer","title":"Anti-Corruption-Layer","text":"<p>If a process is signalled or hit by a correlated message, there is no way to check if the transported variables are set correctly. In addition, the variables are written directly to the execution of the correlated process instance. In case of a multi-instance event-base sub-process this will eventually overwrite the values of the main execution.</p> <p>To prevent all this, a feature called Anti-Corruption-Layer (ACL) is implemented. An ACL is there to protect the execution from bad modifications and influence the way, the modification is executed. For the protection, an ACL relies on a Variables Guards, defining conditions to be satisfied. For the influencing of modification, the <code>VariableMapTransformer</code> can be used.</p> <p>To use the ACL layer you will need to change the way you correlate messages (or signal the execution). Instead of supplying the variables directly to the <code>correlate</code> method of the <code>RuntimeService</code>, the client is wrapping all variables into a map hold by a single transient variable and correlate this variable with the process (we call this procedure variable wrapping). On the process side, an execution listener placed on the end of the catch event is responsible to extract the variable map from the transient variable, check it by passing through the <code>VariablesGuard</code> and finally pass over to the <code>VariableMapTransformer</code> to map from external to internal representation.</p> <p>Here is the code, required on the client side to correlate the message.</p> <pre><code>@Component\nclass SomeService {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\", // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    public void correlate() {\n        VariableMap variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n        runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.checkAndWrap(variables));\n    }\n}\n</code></pre> <p>On the process side, the BPMN message catch event should have an <code>End</code> listener responsible for unwrapping the values. If the listener is implemented as a Spring Bean bounded via delegate expression <code>${messageAclListener}</code> then the following code is responsible for providing such a listener:</p> <pre><code>@Configuration\nclass SomeConfiguration {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\", // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    @Bean(\"messageAclListener\")\n    public ExecutionListener messageAclListener() {\n        return MY_ACL.getExecutionListener();\n    }\n}\n</code></pre> <p>Such a setup will only allow to correlate messages, if the variables provided include a value for the <code>ORDER_ID</code>. It will write all variables provided (<code>ORDER_ID</code> and <code>ORDER_APPROVED</code>) into a local scope of the execution.</p>"},{"location":"user-guide/camunda-bpm-data/examples-java.html","title":"Java Examples","text":"<p>The following example code demonstrates the usage of the library using Java.</p>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#define-variable","title":"Define variable","text":"<pre><code>public class OrderApproval {\n  public static final VariableFactory&lt;String&gt; ORDER_ID = stringVariable(\"orderId\");\n  public static final VariableFactory&lt;Order&gt; ORDER = customVariable(\"order\", Order.class);\n  public static final VariableFactory&lt;Boolean&gt; ORDER_APPROVED = booleanVariable(\"orderApproved\");\n  public static final VariableFactory&lt;OrderPosition&gt; ORDER_POSITION = customVariable(\"orderPosition\", OrderPosition.class);\n  public static final VariableFactory&lt;BigDecimal&gt; ORDER_TOTAL = customVariable(\"orderTotal\", BigDecimal.class);\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#read-variable-from-java-delegate","title":"Read variable from Java delegate","text":"<pre><code>@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public JavaDelegate calculateOrderPositions() {\n    return execution -&gt; {\n      OrderPosition orderPosition = ORDER_POSITION.from(execution).get();\n      Boolean orderApproved = ORDER_APPROVED.from(execution).getLocal();\n      Optional&lt;BigDecimal&gt; orderTotal = ORDER_TOTAL.from(execution).getOptional();\n    };\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#write-variable-from-java-delegate","title":"Write variable from Java delegate","text":"<pre><code>import java.math.BigDecimal;\n\n@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public JavaDelegate calculateOrderPositions() {\n    return execution -&gt; {\n      OrderPosition orderPosition = new OrderPosition(\"Pencil\", BigDecimal.valueOf(1.5), 1);\n      ORDER_POSITION.on(execution).set(orderPosition);\n    };\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#remove-variable-from-java-delegate","title":"Remove variable from Java delegate","text":"<pre><code>import java.math.BigDecimal;\n@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public JavaDelegate calculateOrderPositions() {\n    return execution -&gt; {\n      ORDER_APPROVED.on(execution).removeLocal();\n    };\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#update-variable-from-java-delegate","title":"Update variable from Java delegate","text":"<pre><code>import java.math.BigDecimal;\n@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public JavaDelegate calculateOrderPositions() {\n    return execution -&gt; {\n      OrderPosition orderPosition = ORDER_POSITION.from(execution).get();\n      ORDER_TOTAL.on(execution).updateLocal(amount -&gt; amount.add(orderPosition.getNetCost().multiply(BigDecimal.valueOf(orderPosition.getAmount()))));\n    };\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#fluent-api-to-remove-several-variables","title":"Fluent API to remove several variables","text":"<pre><code>@Configuration\nclass JavaDelegates {\n\n  @Bean\n  public ExecutionListener removeProcessVariables() {\n    return execution -&gt;\n    {\n      CamundaBpmData.writer(execution)\n          .remove(ORDER_ID)\n          .remove(ORDER)\n          .remove(ORDER_APPROVED)\n          .remove(ORDER_TOTAL)\n          .removeLocal(ORDER_POSITIONS);\n    };\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#fluent-api-to-set-several-variables","title":"Fluent API to set several variables","text":"<pre><code>@Component\nclass SomeService {\n\n  @Autowired\n  private RuntimeService runtimeService;\n  @Autowired\n  private TaskService taskService;\n\n  public void setNewValuesForExecution(String executionId, String orderId, Boolean orderApproved) {\n      CamundaBpmData.writer(runtimeService, executionId)\n          .set(ORDER_ID, orderId)\n          .set(ORDER_APPROVED, orderApproved)\n          .update(ORDER_TOTAL, amount -&gt; amount.add(10));\n  }\n\n  public void setNewValuesForTask(String taskId, String orderId, Boolean orderApproved) {\n      CamundaBpmData.writer(taskService, taskId)\n          .set(ORDER_ID, orderId)\n          .set(ORDER_APPROVED, orderApproved);\n  }\n\n  public void start() {\n      VariableMap variables = CamundaBpmData.writer()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n      runtimeService.startProcessInstanceById(\"myId\", \"businessKey\", variables);\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#fluent-api-to-read-several-variables","title":"Fluent API to read several variables","text":"<pre><code>@Component\nclass SomeService {\n\n  @Autowired\n  private RuntimeService runtimeService;\n  @Autowired\n  private TaskService taskService;\n\n  public String readValuesFromExecution(String executionId) {\n      VariableReader reader = CamundaBpmData.reader(runtimeService, executionId);\n      String orderId = reader.get(ORDER_ID);\n      Boolean orderApproved = reader.get(ORDER_APPROVED);\n      if (orderApproved) {\n          // ...\n      }\n      return orderId;\n  }\n\n  public String readValuesFromTask(String taskId) {\n      VariableReader reader = CamundaBpmData.reader(taskService, taskId);\n      String orderId = reader.get(ORDER_ID);\n      Boolean orderApproved = reader.get(ORDER_APPROVED);\n      if (orderApproved) {\n          // ...\n      }\n      return orderId;\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#anti-corruption-layer-wrap-variables-to-correlate","title":"Anti-Corruption-Layer: Wrap variables to correlate","text":"<pre><code>@Component\nclass SomeService {\n\n  private static final AntiCorruptionLayer MESSAGE_ACL = CamundaBpmDataMapper.identityReplace(\n      \"__transient\",\n      true\n  );\n\n  public void correlate() {\n      VariableMap variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n      runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.wrap(variables));\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#anti-corruption-layer-check-and-wrap-variables-to-correlate","title":"Anti-Corruption-Layer: Check and wrap variables to correlate","text":"<pre><code>@Component\nclass SomeService {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\",\n        true,\n        new VariablesGuard(exists(ORDER_ID)),\n        IdentityVariableMapTransformer.INSTANCE\n    );\n\n  public void correlate() {\n      VariableMap variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n      runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.checkAndWrap(variables));\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#define-guards-to-validate-variables-in-the-process","title":"Define Guards to validate variables in the process","text":"<pre><code>@Configuration\nclass VariableGuardConfiguration {\n\n    public static final String MY_GUARD_BEANNAME = \"myGuardBeanName\";\n\n    @Bean\n    public Supplier&lt;Validator&gt;  validatorSupplier() {\n        // assuming dependencys to implement javax.validation:validation-api are present\n        return () -&gt; Validation.buildDefaultValidatorFactory().getValidator();\n    }\n\n    @Bean(VariableGuardConfiguration.MY_GUARD_BEANNAME)\n    public ExecutionListener myGuardBeanName(Supplier&lt;Validator&gt; validatorSupplier) {\n        return new DefaultGuardExecutionListener(\n            new VariablesGuard(\n                Arrays.asList(\n                    exists(REQUIRED_VALUE),\n                    notExists(FUTURE_VALUE),\n                    hasValue(THE_ANSWER, 42),\n                    hasOneOfValues(MY_DIRECTION, Set.of(\"left\", \"up\", \"down\")),\n                    isEmail(USER_EMAIL),\n                    isUuid(DOCUMENT_ID),\n                    matches(DOCUMENT_BODY, this::myDocumentBodyMatcher),\n                    matches(DOCUMENT_BODY, this::myDocumentBodyMatcher, this::validationMessageSupplier),\n                    matchesRegex(DOCUMENT_BODY, \"^Dude.*\", \"Starts with 'Dude'\"),\n                    isValidBean(My_DOCUMENT, validatorSupplier)\n                )\n            ), true);\n    }\n\n    private Boolean myDocumentBodyMatcher(String body) {\n        return true;\n    }    \n\n    private String validationMessageSupplier(VariableFactory&lt;String&gt; variableFactory, String localLabel, Optional&lt;String&gt; option) {\n        return String.format(\"Expecting%s variable '%s' to always match my document body matcher, but its value '%s' has not.\", localLabel, variableFactory.getName(), option.orElse(\"\"));\n    }\n}\n\nclass MyDocument {\n    @Email\n    public String email;    \n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-java.html#example-project","title":"Example project","text":"<p>For more examples, please check out the Java Example project, at GitHub</p>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html","title":"Kotlin Examples","text":"<p>The following snippets demonstrate the usage of the library from Kotlin</p>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#define-variable","title":"Define variable","text":"<pre><code>import io.holunda.data.CamundaBpmDataKotlin\n\nobject Variables {\n    val ORDER_ID = stringVariable(\"orderId\")\n    val ORDER: VariableFactory&lt;Order&gt; = customVariable(\"order\")\n    val ORDER_APPROVED = booleanVariable(\"orderApproved\")\n    val ORDER_POSITION: VariableFactory&lt;OrderPosition&gt; = customVariable(\"orderPosition\")\n    val ORDER_TOTAL: VariableFactory&lt;BigDecimal&gt; = customVariable(\"orderTotal\")\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#define-nonnull-variable","title":"Define nonNull variable","text":"<p>IMPORTANT: Since 1.5.0 all predefined variable types are nullable by default. (For more information, see  here: GitHub Issue) If you want to define a variable to be non-null-able, please call nonNull on variable factory as shown in the example below.</p> <pre><code>import io.holunda.data.CamundaBpmDataKotlin\n\nobject Variables {\n    val ORDER_ID: VariableFactory&lt;String&gt; = stringVariable(\"orderId\").nonNull\n    val CUSTOMER_ID: VariableFactory&lt;String?&gt; = stringVariable(\"orderId\")\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#_1","title":"Kotlin Examples","text":""},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#read-variable-from-java-delegate","title":"Read variable from Java delegate","text":"<pre><code>@Configuration\nclass JavaDelegates {\n\n    @Bean\n    fun calculateOrderPositions() = JavaDelegate { execution -&gt;\n        val orderPosition = ORDER_POSITION.from(execution).get()\n        // order position is of type OrderPosition\n    }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#write-variable-from-java-delegate","title":"Write variable from Java delegate","text":"<pre><code>import java.math.BigDecimal\n\n@Configuration\nclass JavaDelegates {\n\n    @Bean\n    fun calculateOrderPositions() = JavaDelegate { execution -&gt;\n        val orderPosition = ORDER_POSITION.from(execution).get()\n        ORDER_TOTAL.on(execution).set {\n            orderPosition.netCost.times(BigDecimal.valueOf(orderPosition.amount))\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#remove-variable-from-java-delegate","title":"Remove variable from Java delegate","text":"<pre><code>@Configuration\nclass JavaDelegates {\n\n    @Bean\n    fun removeTotal() = JavaDelegate { execution -&gt;\n        ORDER_TOTAL.on(execution).remove()\n    }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#update-variable-from-java-delegate","title":"Update variable from Java delegate","text":"<pre><code>import java.math.BigDecimal\n@Configuration\nclass JavaDelegates {\n\n    @Bean\n    fun calculateOrderPositions() = JavaDelegate { execution -&gt;\n        val orderPosition = ORDER_POSITION.from(execution).get()\n        ORDER_TOTAL.on(execution).update {\n            it.plus(orderPosition.netCost.times(BigDecimal.valueOf(orderPosition.amount)))\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#fluent-api-to-remove-several-variables","title":"Fluent API to remove several variables","text":"<pre><code>import io.holunda.camunda.bpm.data.remove\n\n@Configuration\nclass JavaDelegates {\n\n    @Bean\n    fun removeProcessVariables() = JavaDelegate { execution -&gt;\n        execution\n            .remove(ORDER_ID)\n            .remove(ORDER)\n            .remove(ORDER_APPROVED)\n            .remove(ORDER_TOTAL)\n            .removeLocal(ORDER_POSITIONS)\n    }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#fluent-api-to-set-several-variables","title":"Fluent API to set several variables","text":"<pre><code>@Component\nclass SomeService(\n    private val runtimeService: RuntimeService,\n    private val taskService: TaskService\n) {\n\n    fun setNewValuesForExecution(executionId: String, rderId: String, orderApproved: Boolean) {\n        runtimeService.writer(executionId)\n            .set(ORDER_ID, orderId)\n            .set(ORDER_APPROVED, orderApproved)\n            .update(ORDER_TOTAL, { amount -&gt; amount.add(10) })\n    }\n\n    fun setNewValuesForTask(taskId: String, orderId: String, orderApproved: Boolean) {\n        taskService.writer(taskId)\n            .set(ORDER_ID, orderId)\n            .set(ORDER_APPROVED, orderApproved)\n    }\n\n  fun start() {\n      val variables = createProcessVariables()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n      runtimeService.startProcessInstanceById(\"myId\", \"businessKey\", variables)\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#fluent-api-to-read-several-variables","title":"Fluent API to read several variables","text":"<pre><code>@Component\nclass SomeService(\n  private val runtimeService: RuntimeService,\n  private val taskService: TaskService\n) {\n\n  fun readValuesFromExecution(executionId: String): String {\n      val reader = CamundaBpmData.reader(runtimeService, executionId)\n      val orderId = reader.get(ORDER_ID)\n      val orderApproved = reader.get(ORDER_APPROVED)\n      if (orderApproved) {\n          // ...\n      }\n      return orderId\n  }\n\n  fun readValuesFromTask(taskId: String ): String {\n      val reader = CamundaBpmData.reader(taskService, taskId)\n      val orderId = reader.get(ORDER_ID)\n      val orderApproved = reader.get(ORDER_APPROVED)\n      if (orderApproved) {\n          // ...\n      }\n      return orderId\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#anti-corruption-layer-wrap-variables-to-correlate","title":"Anti-Corruption-Layer: Wrap variables to correlate","text":"<pre><code>@Component\nclass SomeService {\n\n  val MESSAGE_ACL = CamundaBpmDataMapper.identityReplace(\"__transient\", true);\n\n  fun correlate() {\n      val variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n      runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.wrap(variables));\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#anti-corruption-layer-check-and-wrap-variables-to-correlate","title":"Anti-Corruption-Layer: Check and wrap variables to correlate","text":"<pre><code>@Component\nclass SomeService {\n\n    val MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\",\n        true,\n        VariablesGuard(exists(ORDER_ID)),\n        IdentityVariableMapTransformer\n    );\n\n  fun correlate() {\n      val variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n      runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.checkAndWrap(variables));\n  }\n}\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#define-guards-to-validate-variables-in-the-process","title":"Define Guards to validate variables in the process","text":"<pre><code>@Configuration\nclass VariableGuardConfiguration {\n\n    companion object {\n        const val LOAD_OPERATIONAL_FILE_GUARD = \"loadOperationalFileGuard\";\n    }\n\n    @Bean\n    // assuming dependencys to implement javax.validation:validation-api are present\n    fun validatorSupplier(): Supplier&lt;Validator&gt; = Supplier {\n      Validation.buildDefaultValidatorFactory().validator\n    }\n\n    @Bean(LOAD_OPERATIONAL_FILE_GUARD)\n    fun loadOperationalFileGuard(validatorSupplier : Supplier&lt;Validator&gt;): ExecutionListener =\n        DefaultGuardExecutionListener(\n            VariablesGuard(\n                listOf(\n                    REQUIRED_VALUE.exists(),\n                    FUTURE_VALUE.notExists(),\n                    THE_ANSWER.hasValue(42),\n                    MY_DIRECTION.hasOneOfValues(setOf(\"left\", \"up\", \"down\")),\n                    USER_EMAIL.isEmail(),\n                    DOCUMENT_ID.isUuid(),\n                    DOCUMENT_BODY.matches { return@matches true },\n                    DOCUMENT_BODY.matches(this::validationMessageSupplier) { return@matches true },\n                    DOCUMENT_BODY.matchesRegexLocal(Regex(\"^Dude.*\"), \"Starts with 'Dude'\"),\n                    MY_DOCUMENT.isValidBean(validatorSupplier)\n                )\n            ), true\n        )\n\n    private fun validationMessageSupplier(variableFactory: VariableFactory&lt;String&gt;, localLabel: String, option: Optional&lt;String&gt;) =\n        \"Expecting$localLabel variable '${variableFactory.name}' to always match my document body matcher, but its value '${option.get()}' has not.\"\n}\n\nclass MyDocument(@field:Email val email: String)\n</code></pre>"},{"location":"user-guide/camunda-bpm-data/examples-kotlin.html#example-project","title":"Example project","text":"<p>For more examples, please check out the Kotlin Example project, at GitHub.</p>"},{"location":"user-guide/camunda-bpm-data/examples-no-engine.html","title":"Examples without engine","text":""},{"location":"user-guide/camunda-bpm-data/examples-no-engine.html#use-case","title":"Use case","text":"<p>In seldom cases you may want to use the <code>camunda-bpm-data</code> library without Camunda BPM Engine. The most frequent case for this is if you provide a third-party library that is used with or without the engine. In particular, there is no way to use  functionality relying on the Camunda engine without it, but there is some functionality working on simple <code>Map&lt;String, Object&gt;</code> or <code>VariableMap</code>  (from a separate small library <code>org.camunda.commons:camunda-commons-typed-values</code>) which is still usable WITHOUT having the entire Camunda  BPM Engine on the class path.</p>"},{"location":"user-guide/camunda-bpm-data/examples-no-engine.html#limitations","title":"Limitations","text":"<p>Due to limitations provided by the JVM, usage of <code>CamundaBpmData</code> convenience methods is NOT POSSIBLE if the parts of the Java Camunda API is not on the classpath (<code>RuntimeService</code>, <code>TaskService</code>, <code>LockedExternalTask</code>, ...).</p>"},{"location":"user-guide/camunda-bpm-data/examples-no-engine.html#default-solution","title":"Default solution","text":"<p>The default solution for this problem would be to put the <code>org.camunda.bpm:camunda-engine</code> Camunda BPM Engine JAR on the classpath, but don't initialize the Camunda BPM Engine.</p>"},{"location":"user-guide/camunda-bpm-data/examples-no-engine.html#alternative-solution","title":"Alternative solution","text":"<p>In order to make the JAR footprint lighter, we created a special artifact, which provides the Camunda BPM API only (API classes only but no implementation). This artifact includes ORIGINAL Camunda BPM classes of the API.</p> <p>In the same time, we started a discussion with Camunda Team to provide a dedicated API JAR of the engine. We will produce the Camunda BPM API for the upcoming releases. Instead of using the original engine JAR, you might want to put the following artifact on your classpath:</p> <pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;io.holunda.camunda-api&lt;/groupId&gt;\n      &lt;artifactId&gt;camunda-bpm-engine-api&lt;/artifactId&gt;\n      &lt;version&gt;${camunda.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For more information about the Camunda BPM API, please check its GitHub project page:  https://github.com/holunda-io/camunda-bpm-api/</p>"},{"location":"user-guide/camunda-bpm-data/features.html","title":"Features","text":"<ul> <li> <p>Process Variables</p> <ul> <li>The library provides a way to construct a generic adapter for every process variable.</li> <li>The adapter contains variable type.</li> <li>The adapter can be applied in any context (<code>RuntimeService</code>, <code>TaskService</code>, <code>CaseService</code>, <code>DelegateExecution</code>, <code>DelegateTask</code>, <code>DelegateCaseExecution</code>, <code>VariableMap</code>, <code>LockedExternalTask</code>).</li> <li>The adapter offers methods to read, write, update and remove variable values.</li> <li>The adapter works for all types supported by Camunda BPM. This includes primitive types, object and container types ( <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>, <code>Map&lt;K , V&gt;</code> ).</li> <li>The adapter supports global / local variables.</li> <li>The adapter allows a default value or null in case a variable is not set.</li> <li>The adapter support transient variables.</li> <li>Fluent API helper are available in order to set, remove or update multiple variables in the same context (<code>VariableMapBuilder</code>, <code>VariableReader</code> and <code>GlobalVariableWriter</code>).</li> </ul> </li> <li> <p>Process Variable Guards</p> <ul> <li>Generic support for <code>VariableGuard</code> for evaluation of a list of <code>VariableCondition</code>s</li> <li>Condition to check if variable exists.</li> <li>Condition to check if variable doesn't exist</li> <li>Condition to check if variable has a predefined value.</li> <li>Condition to check if variable has one of predefined values.</li> <li>Condition to check if variable matches condition specified by a custom function.</li> <li>Condition to check if variable matches provided regular expression.</li> <li>Condition to check if variable is a valid email address.</li> <li>Condition to check if variable is a valid UUID.</li> <li><code>DefaultGuardTaskListener</code> to construct variable conditions guards easily.</li> <li><code>DefaultGuardExecutionListener</code> to construct variable conditions guards easily.</li> </ul> </li> <li> <p>Anti-Corruption-Layer</p> <ul> <li>Generic support for <code>AntiCorruptionLayer</code> for protection and influence of variable modification in signalling and message correlation.</li> <li>Helper methods for the client to wrap variables in a transient carrier.</li> <li>Execution listener to handle <code>VariableGuard</code>-based conditions and <code>VariableMapTransformer</code>-based modifications.</li> <li>Task listener to handle <code>VariableGuard</code>-based conditions and <code>VariableMapTransformer</code>-based modifications.</li> <li>Factory methods to create <code>AntiCorruptionLayer</code> with a <code>VariableGuard</code> (see <code>CamundaBpmDataACL</code>)</li> <li>Factory methods to create <code>AntiCorruptionLayer</code> without a <code>VariableGuard</code> (see <code>CamundaBpmDataMapper</code>)</li> </ul> </li> </ul>"},{"location":"user-guide/camunda-platform-7-mockito/index.html","title":"Overview","text":""},{"location":"user-guide/camunda-platform-7-mockito/index.html#coming-soon","title":"Coming Soon","text":""},{"location":"user-guide/camunda-platform-7-rest-client-spring-boot/index.html","title":"Overview","text":""},{"location":"user-guide/camunda-platform-7-rest-client-spring-boot/index.html#coming-soon","title":"Coming Soon","text":""},{"location":"user-guide/camunda-process-test-coverage/index.html","title":"Overview","text":""},{"location":"user-guide/camunda-process-test-coverage/index.html#coming-soon","title":"Coming Soon","text":""}]}